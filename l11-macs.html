<h1>Today: Message Authentication Codes (MACs), Wed., March 11th</h1>

<ul>
<li>HMAC</li>
<li>CBC-MAC</li>
<li>PRF-MAC</li>
<li>OTMac</li>
<li>AEAD (Authenticated Encryption with Associated Data)
<ul>
<li>EAX mode</li>
<li>Encrypt then MAC</li>
</ul></li>
<li>Finite fields &amp; number theory</li>
</ul>

<h2>MACs</h2>

<ul>
<li>Not related to confidentiality</li>
<li>Alice wants to send message <code>m</code> to Bob</li>
<li>would like to ensure only <code>m</code> generated by Alice will be accepted by Bob
<ul>
<li>Bob should not accept messages <code>m'</code> generated by Eve</li>
</ul></li>
</ul>

<p>Diagram:</p>

<pre><code>                    m, t = MAC(k, m)
    Alice -----------*-------------------------- Bob
      k               \-&gt; Eve                     k
</code></pre>

<ul>
<li>both Alice and Bob can compute <code>t = MAC(k, m)</code></li>
<li>Eve does not have <code>k</code>, so she can't</li>
</ul>

<p>To verify a message <code>m'</code> with tag <code>t</code>, Bob can simply compute <code>t' = MAC(k, m')</code> and check
that <code>t'</code> is equal to <code>t</code>. As long as only Alice and Bob have <code>k</code>, Bob is sure alice
sent <code>m'</code></p>

<ul>
<li>Eve can successfully guess a new MAC for <code>m</code> with probability <code>2^-l(t)</code>, where
<code>l(t)</code> is the length of the MAC</li>
</ul>

<p>Adversarial model:</p>

<ul>
<li>Eve may ask for a MAC on any message <code>m</code>
<ul>
<li><code>=&gt;</code> gets a list <code>(m, MAC(k, m))</code> for <code>m</code>'s chosen by her</li>
</ul></li>
<li>She wants to forge a message <code>(m', T)</code> that Bob will accept</li>
<li>The scheme is secure if Eve succeeds with probability <code>2^-l(t) + negl(l(t))</code></li>
</ul>

<h3>PRF-MAC</h3>

<pre><code>PRF-MAC(k, m) = h(k || m), where h is a random oracle
</code></pre>

<p>In practice we don't have a random oracle, and iterative hash functions are
susceptible to <em>length-extension attacks</em> where if you have
<code>h(k | m)</code> you can compute <code>h(k | m | extension)</code> without knowing <code>k</code></p>

<h3>CBC-MAC</h3>

<p>Diagram:</p>

<pre><code>        m1     m2            m3
        \|     \|            \|
    o -&gt; +  |-&gt; +  |-&gt; ... -&gt; +  
        \|  |  \|  |         \|  
    k -&gt; E  |   E  |     k'-&gt; E  
         |  |   |  |          \|  
         ----   ----          tag

    where k' = f(k), f is a constant function
</code></pre>

<h3>HMAC</h3>

<ul>
<li>designed to fix length extension attacks that <code>PRF-MAC</code> is susceptible to</li>
<li><code>HMAC(k, m) = h(k_1 || h (k_2 || m))</code>, where
<ul>
<li><code>k_1 = k \xor opad</code></li>
<li><code>k_2 = k \xor ipad</code></li>
</ul></li>
<li>this prevents extension attacks
<ul>
<li><strong>Q:</strong> How?</li>
</ul></li>
</ul>

<h3>OTMac</h3>

<p>We saw with encryption that we have information-theoretic secure encryption like the one-time pad.</p>

<p>Can we also have an information-theoretic secure <em>one-time MAC</em>?</p>

<ul>
<li>Eve is computationally unbounded</li>
<li>Alice and Bob use new key for each MAC computation</li>
</ul>

<p>Table:</p>

<pre><code>                    confidentiality     |    integrity
                   -----------------------------------------     
    unconditional   OTP                 |    OTMac
    conventional    block ciphers       |    MACs
    public-key      PK encryption       |    digital signatures
</code></pre>

<h2>Authenticated Encryption with Associated Data</h2>

<ul>
<li>you may have a situation where parts of the message <code>m</code> are confidential</li>
<li>and another part of the message <code>h</code> (headers?) that need integrity</li>
</ul>

<h3>Encrypt-then-MAC</h3>

<pre><code>    Alice computes:
    c = Enc(k_1, m)
    T = MAC(k_2, h || c)

    transmit header h, c, t

    Bob concatenates h || c and computes t' = MAC(k_2, h || c),
    checks that t = t', and if true, decrypt m = Dec(k_1, c)
</code></pre>

<p><strong>Note:</strong> Applying a MAC to the plaintext instead of the ciphertext can be a bad
idea because the MAC could leak plaintext information</p>

<ul>
<li>MACs have no guarantees about the confidentiality of the tag <code>t</code></li>
</ul>

<p>Notes:</p>

<ul>
<li>this seems to require two passes: one for encrypting <code>m</code> and one for MACing <code>c</code>
<ul>
<li>you can play tricks if you choose the primitives right and make it one pass maybe</li>
</ul></li>
</ul>

<h3>AES-EAX</h3>

<p>Nonce <code>N</code>:</p>

<ul>
<li>generating randomness is hard, so <code>N</code> is pseudo-random</li>
</ul>

<p>Diagram:</p>

<pre><code>          N          M            H
         \|         \|            |
   k -&gt; MAC1  k -&gt; CTR      k -&gt; MAC2
         |         / |            |
         |    c   /  |            |
         *-------/   |            |
         |          \|            |
         |       ---------        |
         |       | ctext |        |
         |       ---------        |
         |           |            |
         |     k -&gt; MAC3          |
         |           |            |
         |           |            |
         -----------|+|------------
                     |
                    \|
                    tag
</code></pre>

<p>Note:</p>

<ul>
<li><code>MACi(k, m) = MAC(k, i || m)</code></li>
</ul>

<h2>Finite fields &amp; number theory</h2>

<h3>Finite fields</h3>

<p><strong>Definition:</strong> <code>(S, +, *)</code>, where:</p>

<ul>
<li><code>S</code> is finite,</li>
<li>contains some notion of zero and one values (identity for addition and multiplication)</li>
<li><code>(S, +)</code> is an abelian (commutative) group with identity zero
<ul>
<li>associativity: <code>a + (b + c) = (a + b) +c</code></li>
<li>identity under zero: <code>a + 0 = 0 + a = a</code></li>
<li>inverses: <code>\forall a, \exists b, s.t. a + b = 0</code>
<ul>
<li><code>b = a^-1</code></li>
</ul></li>
<li>commutativity (abelian)</li>
</ul></li>
<li><code>(S*, *)</code> is an abelian group with identity one
<ul>
<li><code>S* = S - {0}</code></li>
<li>same laws as before</li>
</ul></li>
<li>distributive law (connecting these two groups)
<ul>
<li><code>a*(b+c) = a*b + a*c</code></li>
<li><code>(b+c)*a = b*a + c*a</code></li>
</ul></li>
</ul>

<p><code>GF(p)</code> - finite fields (a.k.a. Galois fields) on <code>p</code> elements <code>{0, 1, ..., p-1}</code></p>

<pre><code>ax + b = 0 (mod p) =&gt; 
x = -b * a^-1

3x + 5 = 6 (mod 7) =&gt;
3x = 1 (mod 7) =&gt; (5 = 3^-1 (mod 7))
x = 5
</code></pre>

<p><code>GF(q)</code> finite field where <code>|S| = q</code>. When do finite fields exists, for what <code>q's</code>?</p>

<p><strong>Theorem:</strong> <code>GF(q)</code> exists iff <code>q = p^k</code> for some prime <code>p, k &gt;= 1</code> (see <a href="http://mathworld.wolfram.com/FiniteField.html">here</a> for more info)</p>

<p><strong>TODO: Proof:</strong></p>

<p>How do we create a <code>GF(p^k)</code> field, where <code>k &gt; 1</code>?</p>

<p>We work with (univariate) polynomials of degree <code>&lt; k</code> with coefficients in <code>GF(p)</code></p>

<pre><code>f(x) = a_k-1 x^k-1 + a_k-2 x^k-2 + ... + a_1 x + a0
</code></pre>

<p>There are <code>k</code> coefficients, so there's <code>p^k</code> such polynomials, <code>=&gt; p^k</code> elements in <code>S</code>
 - </p>

<p>Does it respect the definition of a field?</p>

<ul>
<li>addition: as usual for polynomials</li>
<li>multiplication: we do it <em>modulo an irreducible polynomial of degree <code>k</code></em>
<ul>
<li>irreducible means the polynomial doesn't factor into a product of two smaller polynomials</li>
</ul></li>
</ul>

<p>Example: <code>GF(4) = GF(2^2), p = 2, k = 2</code> is the set of univariate polynomials of 
degree <code>&lt; 2</code> with coefficients in <code>GF(2)</code>. Thus <code>GF(4)</code> has 4 polynomials (4 elements): </p>

<ul>
<li><code>0</code></li>
<li><code>1</code></li>
<li><code>x</code></li>
<li><code>x + 1</code></li>
</ul>

<p>Multiplying them, we work modulo <code>p(x) = x^2 + x + 1, p(x) = 0 =&gt; x^2 = -x-1 =&gt; (in GF(2) -x = x, -1 = 1) =&gt; x^2 = x + 1</code> </p>

<pre><code> *  |   0       1      x    x+1
 --------------------------------
 0  |   0       0      0     0
 1  |   0       1      x    x+1
 x  |   0       x     x+1    1
x+1 |   0      x+1     1     x  


x * x = x^2 = x+1
x * (x + 1) = x^2 + x = (x+1) + x = 1
(x+1)(x+1) = x^2 + x + x + 1 = x^2 + 1 = (x+1) + 1 = x
</code></pre>

<p>How do we choose the modulo <code>x^2 + x + 1</code>? Gotta make sure they are irreducible.</p>

<ul>
<li>You only do it once</li>
</ul>

<p>What about division?</p>

<h4>Repeated squaring</h4>

<p>We want to compute <code>a^b</code>, <code>b</code> is an integer, <code>a</code> is a number in your finite field</p>

<pre><code>      {  1,             if b = 0
      {   
a^b = {  (a^(b/2))^2    if b = even
      { 
      {  a*a^(b-1)      if b = odd
</code></pre>

<p>We have to do <code>&lt;= 2*log_2(b)</code> multiplications</p>

<p>If <code>b</code> is secret, this can be problematic because the runtime is dependent on the value of <code>b</code>.</p>

<p><strong>Fermat's little theorem (FLT):</strong> In <code>GF(q)</code> for all <code>a \in GF(q)*</code>, we have <code>a^(q-1) = 1</code>, where 1 is the multiplicative identity in <code>GF(q)</code></p>

<p><strong>Corallary:</strong> For all <code>a \in GF(q)</code>, we have <code>a^q = a</code></p>

<p><strong>Corallary:</strong> For all <code>a \in GF(q)</code>, we have <code>a^-1 = a^(q-2)</code></p>

<p>Example:</p>

<pre><code>3^-1 (mod 7) = 3^5 = 27 * 9 = 6 * 2 = 12 = 5
</code></pre>
