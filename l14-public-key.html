<h1>Today: Applications of crypto math, Monday, March 30th, 2015</h1>

<p>Today:</p>

<ul>
<li>Pedersen commitments</li>
<li>Public key encryption</li>
<li>ElGamal PK encryption</li>
<li>Semantic security</li>
<li>DDH (Decisional Diffie-Hellman)</li>
<li>IND-CCA2 (chosen ciphertext indistinguishability)</li>
<li>Cramer-Shoup PK encryption</li>
</ul>

<h2>Pedersen commitment</h2>

<pre><code>Commit(x) -&gt; commitment c
Reveal(c) -&gt; opens the commitment, revealing x
</code></pre>

<p>Properties:</p>

<ul>
<li><em>Hiding</em>: commitment <code>c</code> does not reveal anything about <code>x</code>
<ul>
<li>information theoretic (no way it reveals anything)</li>
<li>computational (no feasible way to discover what is revealed)</li>
</ul></li>
<li><em>Binding</em>: can only open <code>c</code> in one way (you can't change what you committed to)</li>
<li><em>Non-malleability</em>: can't produce another commitment to <code>x' != x</code> given <code>c</code></li>
</ul>

<p>One scheme:</p>

<pre><code>c = hash(x || r), r = random nonce
</code></pre>

<p>Pedersen commitment has information-theoretic hiding properties, but computationally-hard binding</p>

<p>Setup: </p>

<ul>
<li>large prime <code>p</code> and <code>q</code>, such that <code>q | p-1</code> (safe prime <code>p = 2q + 1</code>)</li>
<li><code>g</code> generator of order <code>q</code> subgroup <code>Q_p</code></li>
</ul>

<p>Receiver sets up <code>h = g^a mod p</code>, <code>a</code> is random from <code>Z_q</code>, he knows <code>a</code> and it is secret.</p>

<pre><code>Commit(x \in Z_q):
   choose r \in Z_q at random
   c = g^x h^r mod p

Reveal(c):
   reveal x and r
   receiver verifies that c = g^x h^r mod p
</code></pre>

<p>Properties:</p>

<ul>
<li><em>Hiding:</em> Does it hide <code>x</code>? Given <code>g^x h^r mod p</code>, and you don't know <code>a</code>.
<ul>
<li>Claim is that <code>c = g^x h^r = g^x' h^r'</code> can be a commitment for any <code>x</code></li>
</ul></li>
</ul>

<p>Prove that for any <code>x'</code>, there exists an <code>r'</code> such that <code>g^x' h^r' = c</code></p>

<pre><code>g^x g^ar = g^x' g^ar' (mod p) &lt;=&gt; g^(x+ar) = g^(x'+ar') (mod p) &lt;=&gt;
x + ar = x' + ar' (mod q) &lt;=&gt; r' = (x+ar - x') / a = (x-x')/a + r
</code></pre>

<p>See discrete log identity and discrete log properties.</p>

<p>Therefore there exists an <code>r'</code> for any <code>x'</code> such that the commitment <code>c</code> for <code>x</code>
is also a commitment for <code>x' =&gt;</code> <code>c</code> hides <code>x</code>.</p>

<p>Thus, this commitment is <em>perfectly hiding</em> (information theoretic hiding)
because I haven't really committed to any value. I could open it in lots of different ways
(however, we will show it is very hard to open it in different ways)</p>

<ul>
<li><em>Binding:</em> If it's not binding, then I know two ways of opening it <code>c = g^x h^r</code>
and <code>c = g^x' h^r'</code>, and I know <code>x, r, x', r'</code> for the same commitment <code>c</code></li>
</ul>

<p>Then, I can compute a discrete log on <code>h</code> and reveal <code>a</code>:</p>

<pre><code>g^(x+ar) = g^(x'+ar') &lt;=&gt; x+ar = x' +ar' &lt;=&gt; a = (x-x')/(r-r')
</code></pre>

<p>This is (sort of) a contradiction, because I assumed discrete log is hard and I 
can't know <code>a</code>. If I had an algorithm for efficiently computing the <code>x'</code> and <code>r'</code>
then I would have an algorithm for computing discrete logs efficiently.</p>

<p>Thus, it's computationally binding.</p>

<ul>
<li><em>Non-malleability:</em> If I bid with commitment <code>c</code> for value <code>x</code> can you compute
a <code>c'</code> for a value <code>x+1</code> that will let you bid higher than me?</li>
</ul>

<p>Yes:</p>

<pre><code>c = g^x h^r, commits x
=&gt; c' = c * g = g^(x+1) h^r, commits x+1
</code></pre>

<p>In some applications that's a bad thing.</p>

<p>You can hash <code>x</code> first, to fix this!</p>

<h2>Public key encryption</h2>

<p>What do we need:</p>

<pre><code>Keygen(1^l) -&gt; (pk, sk)

Enc(pk, m) -&gt; c
 - typically this will be randomized to avoid guessing attacks
   where attackers try different m's and hope to get the attacked c

Dec(sk, c) -&gt; m
</code></pre>

<p>We need <code>Dec(sk, Enc(pk, m)) = m</code></p>

<p>RSA doesn't meet this definition because it is not randomized. ElGamal is.</p>

<h2>ElGamal</h2>

<pre><code>G = &lt;g&gt; (cyclic group generated by g)
discrete log needs to be hard in G

Keygen(): 
    pick x at random from {0, 1, ... |G|-1}
    sk = x
    pk = g^x 
    return (pk, sk)

Note:
 - security parameter is the group size |G|
 - discrete logarithm is hard =&gt; given pk = g^x it is hard to obtain sk = x

Enc(g^x, m):
    pick k at random from {0, 1, ... |G|-1}
    return (g^k, m*((g^x)^k))

Dec(x, c = (a = g^k, b = m*g^(xk))):
   ( you have x, so you can compute g^(xk) )
   g^(xk) = (g^k)^x = a^x
   m = b/(a^x)


Note:
 - assuming we can represent messages as members of the group G
</code></pre>

<p>If your <code>m</code>'s are too big, you would need a huge group <code>G</code>. Typically, you keep
a reasonable group size of 2048 bits and you encrypt a symmetric key using ElGamal.
Then you encrypt your big message <code>m</code> with the symmetric key.</p>

<h3>ElGamal as a Diffie-Hellman key exchange</h3>

<pre><code>Alice                                   Bob
                    g^x
        ------------------------------&gt;

                a = g^k
        &lt;------------------------------

DH key                                  DH key
= (g^k)^x = g^(xk)                      = (g^x)^k = g^(xk)

                b = m * g^(xk)            
        &lt;------------------------------
</code></pre>

<h3>Why does ElGamal work?</h3>

<p>What are our security specifications?</p>

<h4>Semantic security</h4>

<ol>
<li>Phase I
<ul>
<li>Adversary sees <code>pk</code></li>
<li>Adversary outputs <code>m_0, m_1</code> different than each other, <code>|m_0| = |m_1|</code></li>
<li>Adversary maybe keeps some state <code>s</code></li>
</ul></li>
<li>Phase II
<ul>
<li>Examiner picks a random bit <code>b</code></li>
<li>Examiner encrypts one of the messages: <code>c* = Enc(pk, m_b)</code></li>
<li>Examiner sends <code>c*</code> to adversary, he has to figure out if <code>m_0</code> or <code>m_1</code>
were encrypted
<ul>
<li>Adversary can look at his state <code>s</code></li>
</ul></li>
<li>Adversary gets encryption oracle access, but <em>no decryption</em> oracle access</li>
<li>Adversary outputs <code>b*</code>, which is his guess for <code>b</code> (ie: his guess for
which message was encrypted)</li>
<li>Adversary wins the game if <code>b* = b</code></li>
</ul></li>
</ol>

<p>Getting the right answer half the time is easy: just guess. However, doing any
better than that should be hard!</p>

<p>Scheme is <em>semantically secure</em> if the probability that the adversary wins is
<code>1/2 + negl(l)</code>, where <code>l</code> is the security parameter</p>

<p>From this definition, it should be clear that the scheme should be non-deterministic or 
randomized, because the adversary gets oracle access. This would allow him to check
if <code>Enc(m_0) = c*</code> or <code>Enc(m_1) = c*</code> if the scheme were deterministic.</p>

<p>Semantic security requires either:</p>

<ul>
<li>randomness in E</li>
<li>have some state in E that results in different ciphertexts for the same message
<ul>
<li>maybe a simple counter passed through a hash function can work</li>
</ul></li>
</ul>

<h2>Decisional Diffie-Hellman (DDH)</h2>

<p>Not computing discrete logs (CDH assumption).</p>

<p>Given group <code>G</code> and a generator <code>g</code>, it is infeasible to decide whether a given
triple of elements is of form:</p>

<ul>
<li><code>(g^a, g^b, g^c)</code> where <code>a,b,c</code> are random</li>
</ul>

<p>or,</p>

<ul>
<li><code>(g^a, g^b, g^ab)</code> where <code>a,b</code> are random</li>
</ul>

<p>It turns out it is very hard to tell these apart, given that triple.</p>

<p><em>Theorem:</em> If we assume DDH is hard, then CDH is hard. (because if you could compute
it, then you can recognize it).</p>

<blockquote>
  <p>"DDH is considered a stronger assumption than discrete log, because there are
groups for which detecting DDH tuples is easy, but computing discrete logs is
believed to be hard. Thus, requiring that the DDH assumption holds in a group is
a more restricting requirement." -- Wikipedia</p>
</blockquote>

<p><em>Theorem:</em> ElGamal is semantically secure <code>&lt;=&gt;</code> DDH holds in <code>G</code></p>

<p><a href="#elgamalproofsketch"></a></p>

<p><em>Proof <code>&lt;=</code>:</em> Suppose you have a way to break the IND-CPA game for ElGamal <code>=&gt;</code>
then you can solve a DDH instance. Let's see how:</p>

<p>Being able to break the IND-CPA means that given a ciphertext <code>c*</code>, either of 
<code>m1</code> or of <code>m2</code> (where <code>m1</code> and <code>m2</code> are chosen by you).</p>

<pre><code>c1 = Enc(g^x, m1) = (g^k1, m1*(g^x)^k1)
c2 = Dec(g^x, m2) = (g^k2, m2*(g^x)^k2)

c* = c1 or c2
</code></pre>

<p>...you have an algorithm <code>A</code> that is able to tell which one of <code>m1</code> or <code>m2</code> is
encrypted in <code>c*</code></p>

<p>We'll see how you can build another algorithm <code>D</code> that can solve the DDH problem
given an algorithm for <code>A</code></p>

<h2>Back to ElGamal</h2>

<p>ElGamal has nice properties, like homomorphism.</p>

<p>Suppose I have:</p>

<pre><code>sk = x
pk = y = g^x

E(m1) = c1 = (g^r, m1 * y^r)
E(m2) = c2 = (g^s, m2 * y^s)
</code></pre>

<p>Then,</p>

<pre><code>c1*c2 = (g^(r+s), m1*m2 * y^(r+s)) = E(m1*m2)
</code></pre>

<p>In particular if <code>m2 = 1</code>, then <code>c1 * c2</code> will rerandomize the encryption of <code>m1</code></p>

<p>This is useful for <em>mix-nets</em>.</p>

<p>It can also be annoying if you want to meet a stronger definition of security.</p>

<h2>IND-CCA2: Indistinguishability under chosen-ciphertext attack</h2>

<p>We can change the semantic security game, by allowing the adversary to decrypt 
as well (except decrypting the challenge ciphertext).</p>

<p>You can see that because ElGamal ciphertexts can be rerandomized => it is not
secure under IND-CCA2 (adversary can generate different ciphertext for the same
message <code>m_b</code> and ask decryption oracle to decrypt, revealing <code>m_b</code> and thus <code>b</code>)</p>
